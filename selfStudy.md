

## iOS selfStudy

---

### Optional

* 일반 자료형은 nil을 가질수없다. 문자열이나 정수형 같은..., 대신 옵셔널 타입으로 선언된 자료형은 nil값을 저장할 수 있다. 
* 옵셔널 타입이 실제로 가질수있는 값의 종류는 두가지다. 오류가 발생할 가능성이 있지만 실제 실행 결과에서는 오류가 발생하지 않았을때 nil이 아닌값, 실제 실행결과에서 오류 발생시 반환되는 nil값이 두번쨰.
* 잠재적으로 오류가 발생할 가능성이 있는 상황 => 옵셔널 타입을 사용.
* 일반 자료형을 옵셔널 타입으로 정의하는 방법 -> ?만 붙이면 된다.

> 옵셔널 해제방식은 명시적 해제와 묵시적 해제로 나뉜다. 

* 명시적해제는 다시 강제적해제와 비 강제적 해제로 나뉘고
* 묵시적해제는 컴파일러에 의한 자동해제와 !연산자를 사용한 자동해제로 나눌수있다.

옵셔널 강제해제는 옵셔널 타입의 변수나 상수 뒤에 !만 붙이면 된다. 강제 해제 연산자를 사용할때는 먼저 옵셔널 값이 nil인지 점검해야 한다. 

비강제적인 해제 구문으로는 if 구문 내에서 조건식 대신 옵셔널 타입의 값을 일반 타입의 변수나 상수에 할당하는 구문을 사용하는 방식으로 옵셔널 바인딩이라고 한다. If let 구문이 있다.

컴파일러에 의한 옵셔널 자동해제는 항상 !연산자를 사용하여 옵셔널을 강제 해제하거나 옵셔널 바인딩을 통해 일반 자료형으로 바꿔줘야한다. 

묵시적해제는 옵셔널이지만 값을 사용하려고 할때는 자동으로 옵셔널이 해제된 값을 제공하기 때문에 굳이 ! 연산자를 사용할 필요가 없는 구문. 일반 옵셔널 타입의 변수선언시 ! 연산자를 ? 대신에 붙여주면 끝.

---

### $Function$

함수는 뒤에 매개변수를 가질때 콜론을 붙여준다. 

ex) incrementBy: 

##### *튜플*

튜플의 속성으로 튜플을 반환하는 함수의 반환값을 대입 받은 변수나 상수는 튜플의 인덱스를 이용하여 튜플 내부의 요소로 사용할수있다. 

Ex) var Uinfo = getUserInfo()

UInfo.0 , UInfo.1 ...이런식으로 사용가능하다

튜플 항목은 언더바를 이용하면 변수 할당없이 건너뛸수 있다.

---

#### $Closure$ - 익명함수

### 일급함수

다음 조건을 만족해야 일급함수라고 한다.

* 객체가 런타임에도 생성이 가능해야 한다.
* 인자값으로 객체를 전달할 수 있어야 한다.
* 반환값으로 객체를 사용할 수 있어야 한다.
* 변수나 데이터 구조 안에 저장할 수 있어야 한다.
* 할당에 사용된 이름과 관계없이 고유한 구별이 가능해야 한다.

###### 일급함수의 특성

1. 변수나 상수에 함수를 대입할 수 있다.

ex) let fn1 = foo(base: 5)

> ##### 함수를 호출할때 함수의 이름 다음에 함수 호출 연살자를 붙여야 했으나, 굳이 함수의 이름이 아니더라도 함수가 할당된 변수라면 그 변수에 함수 호출연산자() 를 붙여서 함수를 호출할 수 있다.

함수는 어차피 어떤값을 입력받는지와 어떤 값을 반환하는지 뿐이기 때문에 (인자 타입1, 인자 타입2) -> 반환 타입 이런 식으로 축약할 수 있다!!!! 단 아무것도 반환하지 않는 함수일 경우, Void라고 명시해야한다. void는 빈 튜플 타입을 나타내는 값으로 타입 얼리어스로 정의된 단어이다.

2. 함수의 반환 타입으로 함수를 사용할 수 있다.
3. 함수의 인자값으로 함수를 사용할 수 있다.

클로저란 외부 함수 내에서 내부 함수를 반환하고, 내부 함수가 외부 함수의 지역 변수나 상수를 참조할 때 만들어진다. 

스위프트에서 클로저라고 부르는 객체는 다음 세가지 경우 중 하나에 해당한다.

1. 전역함수
2. 중첩함수
3. 클로저 표현식

클로저 표현식은 func 키워드 함수명을 제외한 나머지 부분만 작성하는 경량 문법을 사용한다.

---

#### $Property$

저장 프로퍼티와 연산 프로퍼티 두 종류가 있다.

##### 저장 프로퍼티

* 입력된 값을 저장하거나 저장된 값을 제공하는 역할

* 상수 및 변수를 사용해서 정의 가능

* 클래스와 구조체에서는 사용이 가능하지만, 열거형에서는 사용할 수 없다.

클래스안에 저장 프로퍼티를 선언시 초기화 하는법

1. init()함수로 초기화 
2. 프로퍼티를 옵셔널 타입으로 바꿔준다.
3. 프로퍼티에 초기값을 할당해준다.

클로저를 이용하여 저장 프로퍼티를 초기화 할때 상수와 변수 모두를 사용할수 있다. 구문의 형식은 다음과 같다.

```swift
var/let 프로퍼티명: 타입 = {

 정의내용

return 반환값

}() 
```

이렇게 정의된 클로저 구문은 클래스나 구조체의 인스턴스가 생성될 때 함께 실행되어 초기값을 반환하고 이후로는 해당 인스턴스 내에서 재실행되지 않는다.

##### 연산 프로퍼티

- 특정 연산을 통해 값을 만들어 제공하는 역할
- 변수만 사용해서 정의 가능
- 클래스, 구조체, 열거형에서 모두 사용가능

##### 프로퍼티 옵저버

프로퍼티의 값이 변경되었을때 프로퍼티의 값이 설정되면 무조건 호출된다.

- willSet - 프로퍼티의 값이 변경되기 직전에 호출되는 옵저버

- didSet - 프로퍼티의 값이 변경된 직후에 호출되는 옵저버

##### 타입 프로퍼티

인스턴스를 따로 생성하지 않고 클래스나 구조체 자체에 값을 저장하게 되며 이를 타입 프로퍼티라고 부른다.

클래스나 구조체 , 열거형 객체 내에 선언하는 것이므로 선언된 객체 내에서만 접근 가능한 범위를 가진다.

정의

```swift
static let/var 프로퍼티명 = 초기값
*or*
class let/var 프로퍼티명 : 타입 {
  get {
    return 반환값
  }
  set {
    
  }
}
```

---

#### $Up / Down Casting $

업 캐스팅

* 객체 as 변환할 타입

다운 캐스팅

* 객체 as? 변환할 타입
* 객체 as! 변환할 타입

---

##### 열거형 정의

```swift
enum Direction {
case north
case south
case east, west
}
```

---

## $UI$

* UIScreen - 기기에 연결되는 물리적인 화면을 정의하는 객체
* UIWindow - 화면 그리기 지원 도구를 제공하는 객체
* UIView - 그리기를 수행할 객체 시트
* UIKit - 화면 구성용 객체들이 들어있는 프레임 워크
* AppDelegate는 앱 전체의 생명주기 관리를 위임받은 객체인 앱 델리게이트를 구현한 클래스이다. App Delegate 객체는 앱내에서 오직 하나의 인스턴스만 생성되도록 시스템적으로 보장받는다.

---

##### 뷰의 상태변화 

* viewDidLoad() - 초기화 작업을 할때 ,로드된 직후 호출

* viewWillAppear() - 로드되기 직전에 호출

* viewDidAppear() - 추가되어 화면이 표시되면 호출되는 메서드

* viewWillDisappear() - 뷰가 계층에서 사라지기 직전에 호출되는 메소드

* viewDidDisappear() - 뷰가 계층에서 사라진 후 호출되는 메소드

---

#### 화면 전환 기법

1. 뷰를 이용한 화면 전환
2. 뷰 컨트롤러 직접 호출에 의한 화면 전환

present()로 뷰 컨트롤러를 호출하면 새로운 객체가 생성되는 동시에 기존 화면 위로 표시된다. 

네비게이션 컨트롤러에 의해 화면이 전황되었을 때 이전 화면으로 되돌아가는 메소드는 popViewController()이며, 이 메소드는 이전 화면으로 되돌아갈 때 애니메이션 처리를 할것인지 여부로 인자값으로 입력받는다. 

* 매뉴얼 세그 

자동 액션세그와 달리 수동 실행 세그웨이이다. 

performSegue(withIdentifier: <세그웨이 식별자>, sender: <세그웨이 실행 객체>)

* 커스텀 세그

---

UserDefaults 객체

UserDefaults 객체를 사용하여 값을 주고받을수 있다.

```swift
let ud = UserDefaults.standard
ud.set(self.email.text, forkey: "email")
ud.set(self.isUpdate.text, forkey: "isUpdate")
ud.set(self.interval.text, forkey: "interval")
//UserDefaults에 저장한 객체는 함께 저장된 키를 통해 구분된다.
```

---

#### 싱글톤

##### **앱 전체에서 공유될 수 있는 자원들을 캡슐화한 객체** 

특정한 용도의 객체를 하나 만들어서 공통적으로 사용하고 싶을 때 사용하는 방법. 메모리낭비 방지, 데이터 공유 가능. 앱의 생명 주기 동안 하나의 인스턴스만 생성을 보장하는 클래스를 의미. 이는 단순히 하나의 인스턴스 생성을 보장하는 것이 아니라 **앱 전체에서 공유될 수 있는 자원들을 캡슐화한 객체**, 예시) UserDefault, URLSession이 있다.

---

## $Delegate Pattern$

하나의 객체가 모든 일을 처리하는 것이 아니라 처리해야 할 일 중 일부를 다른 객체에 넘기는 것을 의미.

delegte속성은 델리게이트 메소드가 구현된 객체의 참조 정보를 저장한다.

---

#### 최초 응답자(First Responder)

모바일 기기의 디스플레이에 앱의 콘텐츠를 표현하기 위해 사용하는 UIWindow 객체는 사용자 인터페이스 구조에서 사용자에 가장 가까이 위치한 객체로 사용자로부터 발생하는 터치 관련 이벤트를 내부 객체로 전달하는 역할을 담당한다.

---

#### 테이블 뷰

테이블 뷰 컨트롤러 -> 테이블 뷰 -> 테이블 뷰 셀 -> 컨텐츠 뷰

프로토 타입 셀에는 셀 컨텐츠와 악세서리 뷰가 있다.

프로토타입 셀에는 자동으로 이미지나 텍스트 콘텐츠를 삽입할수 있는 속성이 제공된다. 

필수 구현 메소드 

1. ##### tableView(_: numberOfRowInSection:)

* 테이블 뷰가 생성해야 할 행의 개수
* 이 메소드에 의해 테이블 뷰의 행 수가 결정되는 것.
* 인자로 테이블 뷰의 객체 정보와 섹션정보를 전달한다. 

2. ##### tableView(_: cellForRowAt:)

* 각 행이 화면에 표현해야 할 내용을 구성하는데 사용
* 인자로 테이블 뷰의 객체 정보와 구성할 행에 대한 참조 정보를 전달한다.

3. ##### tableView(_: didSelectRowAt:)

* 특정 행을 선택했을 때 호출되는 메소드
* dequeueReusableCell(withIdentifier:) -> 사용된 테이블 셀 인스턴스가 폐기되지 않고 재사용을 위해

```swift
let cell = tableView.dequeueReusableCell(withIdentifier: "ListCell")!
cell.textLabel?.text = row.title
//만약 테이블 셀의 textLabel 속성에 값이 있으면 하위 속성인 .text에 row.title 값을 대입하고, 없으면 아무것도 처리하지 않는다. -> 옵셔널 체인!
```

---

$viewWithTag$

---

UIImage(named: ) // 프로젝트 내에 있는 이미지를 읽어 객체를 생성한다.

```swift
var img = UIImage(named: <프로젝트 내 파일 경로>) 
//이미지의 이름뿐만 아니라 원래는 경로설정도 해줘야함.
```

---

##### 테이블 뷰 의 행 높이 결정

1. tableView(_: estimatedHeightForRowAt:)

* 테이블 뷰에서 특정 행의 높이를 설정하고 싶을때 사용하는 메소드
* self.tableView.rowHeight = <원하는 행 높이>

2. 셀프사이징 셀

* estiamtedRowHeight 프로퍼티 -> 셀 전체의 높이를 결정하기 전에 임시로 사용할 셀의 높이를 나타낸다.
* UITableViewAutomaticDimension 객체 -> rowHeight 속성에 대입되어 높이값이 동적으로 설정될 것을 테이블 뷰에 알려주는 역할을 한다.

---

### 네트워크 통신

* 소켓 방식

* 비연결 지향 통신 - http등의 프로토콜. 
* RESTful 방식

www과 같은 분산 하이퍼 미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식. 네트워크 자원을 정의하고 자원에 대한 주소를 관리하는 방법이다. http프로토콜을 바탕으로 필요한 데이터를 별도의 규약 없이 주고받기만 하면된다.

RESTful 시스템은 일반적으로 서버에게 요청하려는 정보를 URI를 통해서 나타낸다. 요청 정보는 URI 단위마다 슬래시로 구분된다. 

일반적으로 서버에 요청하는 정보의 타입은 쓰기 읽기 수정 삭제의 네 가지로 구분된다. 일반적으로 웹에서 사용되는 http 메소드의 종류는 get, post 두가지이다. 데이터를 요청하려면 get을 사용하고, 데이터를 전송하려면 post를 사용한다. 

#### XML 방식과 JSON 방식

* XML 은 태그로 이루어진 마크업 형식. 대신 데이터의 용량이 커질수 있다.
* JSON 은 자바스크립트 언어에서 객체의 속성을 표현하기 위한 방법

#### JSON 방식

데이터 구조를 집합, 리스트 두 종류로 나눌수있다. 

JSON 객체는 {키 : 데이터} 형태로 이루어진 딕셔너리 데이터 집합이다. 

JSON 배열은 [ ] 형태 이다. 데이터를 파싱할 때는 JSONSerialization 객체의 jsonObject() 메소드를 사용하는것이 좋다.

---

##### ViewController 에서 테이블 뷰를 추가하고 싶을 땐,

* tableViewDataSource 와 tableViewDelegate를 상속받아 필요한 메소드를 구현해줘야한다. 
* 클래스(*ViewController*)에 데이터 소스나 델리게이트를 사용하는 객체(*tableView*)가 추가되면 이들 객체가 필요한 메소드를 어디서 찾을수 있는지에대한 객체 참조 정보를 알려줘야한다. 

```swift
self.tableView.dataSource = self
self.tableView.delegate = self
```

---

##### ICon size

보통 탭바는 알파값만을 이용하여 제작하는 편이 좋다.

30 x 30 - sample.png

60 x 60 - sample@2x.png

90 x 90 - sample@3x.png

---

##### Auto-Resizing , Auto-Layout

* 자동 크기 조절

---

